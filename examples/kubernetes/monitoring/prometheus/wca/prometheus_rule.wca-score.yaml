# The rules are adjusted for parameters of monitoring tool WCA defined in
# examples/kubernetes/monitoring/wca/wca-config.yaml
# Especially:
# interval=60.0 [seconds],
# wss_membw_threshold=0.01.

apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: wca-score
spec:
  groups:

  - name: wca-score
    rules:

    # ============================ tasks ===================================

    # Helper metrics
    # Note: heuristic for approximation of R/W ratio for a task; 3m set to be sure to have in each range at least 2 points;
    - record: task_memory_rw_ratio
      expr: '(rate(task_offcore_requests_demand_data_rd[3m]) + rate(task_offcore_requests_demand_rfo[3m])) /
             (rate(task_offcore_requests_demand_data_rd[3m]) + 2*rate(task_offcore_requests_demand_rfo[3m]))'
      labels:
        source: wca
    - record: task_mbw
      expr: 'rate(task_mem_bandwidth_bytes[3m]) / 1e9'
      labels:
        source: wca
    - record: task_memory_rw_ratio_ # just added 2lm label
      expr: 'task_memory_rw_ratio'
      labels:
        memory: 2lm
    - record: task_mbw_ # just added 2lm label
      expr: 'task_mbw'
      labels:
        memory: 2lm
    - record: task_mbw_read
      expr: 'task_mbw_ * task_memory_rw_ratio_'
    - record: task_mbw_write
      expr: '(1 - task_memory_rw_ratio_) * task_mbw_ * on(memory,node) group_left node_mbw_write_weight{source="wca"}'
    - record: task_mbw_flat
      expr: 'task_mbw_read + task_mbw_write'

    # Ignore first 30m=3m*10=30m of run of each task for WSS, MBW.
    - record: task_mbw_flat_ignore_initialization
      expr: 'task_mbw_flat and count_over_time(task_mbw_flat[30m:3m]) >= 9'
      labels:
        source: wca
    - record: task_wss_ignore_initialization
      expr: 'task_working_set_size_bytes and count_over_time(task_working_set_size_bytes[30m:3m]) >= 9'
      labels:
        source: wca

    # ============================ apps ===================================

    # For graphana dashboard.
    - record: app_count
      expr: count(task_up) by (app)

    - record: app_cpu
      expr: 'max(max_over_time(task_requested_cpus[7d])) by (app)'
      labels:
        source: wca
    - record: app_mem
      expr: 'max(max_over_time(task_requested_mem_bytes[7d])) by (app) / 1e9'
      labels:
        source: wca
    - record: app_mbw_flat
      expr: 'quantile(0.95, quantile_over_time(0.95, task_mbw_flat_ignore_initialization[7d])) by (app, source)'
    - record: app_wss
      expr: 'quantile(0.95, quantile_over_time(0.95, task_wss_ignore_initialization[7d])) by (app, source) / 1e9'

    - record: app_req
      expr: 'app_cpu'
      labels:
        dim: cpu
    - record: app_req
      expr: 'app_mem'
      labels:
        dim: mem
    - record: app_req
      expr: 'app_mbw_flat'
      labels:
        dim: mbw_flat
    - record: app_req
      expr: 'app_wss'
      labels:
        dim: wss

    # --------------------- Profiles APP -----------------------
    #
    # app profile by mem
    - record: profile_app_by_mem
      expr: 'app_req{dim="cpu"} / on(app, source) app_req{dim="mem"}'
      labels:
        index: cpu
    - record: profile_app_by_mem
      expr: 'app_req{dim="mbw_flat"} / on(app, source) app_req{dim="mem"}'
      labels:
        index: mbw_flat
    - record: profile_app_by_mem
      expr: 'app_req{dim="wss"} / on(app, source) app_req{dim="mem"}'
      labels:
        index: wss

    # ======================== normalization profile ========================
    - record: profile_app_by_mem_norm
      expr: 'profile_app_by_mem / on (index, source) group_left profile_nodes_by_mem{memory="2lm"}'

    # Must contains all 3 dimensions: cpu, wss, membw.
    - record: profile_app_by_mem_norm_3dim
      expr: profile_app_by_mem_norm and on(app, source) count(profile_app_by_mem_norm) by (app, source) == 3

    # ======================== SCORE calculation ==========================
    - record: profile_app_score_max # lower is better for 2lm
      expr: 'max(profile_app_by_mem_norm_3dim{index=~"cpu|mbw_flat|wss"}) by (app, source)'

